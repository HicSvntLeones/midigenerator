from utils.midilogger import *
from generators.midi_encoder import MidiEncoder

# This takes a list of commands from CommandGenerator and passes a list of event tuples sorted by delta_time/track to a MidiEncoder.

class MetaEncoder:
    def __init__(self, event_sheet, metadata):
        stamp(4, f"Initiated MetaEncoder with {metadata}")
        self.setup(event_sheet, metadata)
        self.main()

    def main(self):
        self.generate_metacode()
        self.sort_metacode()
        self.pass_to_encoder(self.metadata, self.event_list)

    def setup(self, event_sheet, metadata):
        self.input_sheet = event_sheet
        self.metadata = metadata
        self.event_list = []
        stamp(5, "MetaEncoder setup complete.")

    def generate_metacode(self):
        stamp(4, "Generating metacode...")
        self.write_header() 
        self.write_track(0)
        for i in range (1, self.metadata['track_count']+1):
            self.write_track(i)

    def sort_metacode(self):
        stamp(4, "Sorting metacode...")
        for i in range (0, self.metadata['track_count']+1):
            self.sort_track_by_time(i)
        stamp(4, "Metacode sorted.")

    def sort_track_by_time(self, track_no):
        stamp(4, f"Sorting track {track_no}")
        if track_no == 0:
            stamp(4,"Track 0 does not get sorted.")
            stamp(5,f"Track 0 remains: {self.event_list[track_no]}")
            return
        timed_indexes = self.event_list[track_no][1:-1]
        stamp(5,f"Sorting {timed_indexes}, excluding, {self.event_list[track_no][:1]} and {self.event_list[track_no][-1:]}")
        timed_indexes.sort(key=lambda event: event[1])
        self.event_list[track_no][1:-1] = timed_indexes
        stamp(5, f"Sorted track {track_no}:{self.event_list[track_no]}")

        

    def pass_to_encoder(self, metadata, event_list):
        midi_encoder = MidiEncoder(event_list, metadata)

    def write_header(self):
        stamp(4, "Writing header...")
        self.event_list.append([('MThd', 6, 1,self.metadata['track_count'],self.metadata['ppq'])])
        stamp(4, f"Header written: {self.event_list[0]}")        

    def write_track(self, track_no):
        stamp(4, f"Writing track {track_no}...")
        if track_no == 0:
            stamp(5, f"Index 0 track. Writing inital track setup.")
            self.event_list[track_no].append(('MTrk','UNSET')) # Only append to sublist, because track 0 is generated by header.
            self.event_list[track_no].append(('Set Tempo', 0, self.metadata['bpm']))
            self.event_list[track_no].append(('Set Time Signature', 0, self.metadata['time_sig_num'], self.metadata['time_sig_den'],24,8))
            if self.metadata['instruments'] == 'default':
                self.event_list[track_no].append(('Control Change', 0, 0, 0, 0)) 
                self.event_list[track_no].append(('Program Change', 0, 0, 0)) 
            self.write_end_track(track_no)
            stamp(5, f"Index 0 track setup.")
            self.write_from_event_list(track_no)
        else:
            self.event_list.append([('MTrk','UNSET')]) # Append to list, generating new sublist
            self.write_from_event_list(track_no)
            self.write_end_track(track_no)
        stamp(4, f"Finished writing track {track_no}:{self.event_list[track_no]}")

    def write_from_event_list(self, track_no):
        stamp(4, f"Scanning for track {track_no} events...")
        track_items = [d for d in self.input_sheet if d.get('track') == track_no]
        if track_items == []:
            stamp(5, f"No track {track_no} events found: Skipping.")
            return
        for event in track_items:
            self.handle_manager(event)
        stamp(4, f"Finished writing track {track_no} events.")

    def handle_manager(self, event):
        stamp(5, f"Handling event: {event}")
        if event['encoded'] == True:
            stamp(3, f"Event {event} already encoded.")
        match event['type']:
            case 'note':
                self.handle_note(event)
            case _: 
                stamp(2, f"Unhandled event type in {event}")

    def handle_note(self, event):
        on_time = event['ppq_time']
        off_time = event['ppq_time']+event['ppq_length']
        track = event['track']
        note_on_event = ('Note On', on_time, event['channel'], event['pitch'], event['velocity'])
        note_off_event = ('Note Off', off_time, event['channel'], event['pitch'], event['velocity'])
        self.event_list[track].append(note_on_event)
        self.event_list[track].append(note_off_event)
        stamp(5, f"Wrote to track {track}: {note_on_event} and {note_off_event}")

    def write_end_track(self, track_no):
        self.event_list[track_no].append(("End Track",))
        stamp(5, f"Wrote End Track to track {track_no}")
        








